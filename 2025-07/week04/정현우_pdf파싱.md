# PDF Parser, Extractor를 직접 만드는 것은 왜 어려운가 - PDF의 구조적 특징을 중심으로

## 들어가며
요즘은 사용자의 이력서 및 포트폴리오를 분석해 개인화된 기술면접 질문을 생성해주는 서비스를 만들고 있습니다. 이를 위해 전에 PDF를 내가 원하는 형식으로 정리하는(parser), 또는 하이퍼 링크와 같은 특정 데이터를 추출(extractor)를 직접 만들거나 내 서버에서 직접 돌릴까 했습니다. 

하지만 알아보니 안그러는게 정신건강상 좋겠더라구요. HTML에서 텍스트를 추출하는 것처럼 쉬울 줄 알았는데, 왜 PDF는 이렇게 까다로운 걸까요?

이번에는 PDF의 내부 구조부터 파싱의 어려움, 그리고 보안 고려사항까지 개발자 관점에서 깊이 있게 살펴보겠습니다.

먼저, PDF의 내부 구조부터 살펴보겠습니다.

## PDF란 무엇인가? - HTML과의 비교를 통한 이해

### HTML vs PDF: 근본적 차이점

HTML과 PDF는 모두 문서를 표현하지만, 그 철학은 완전히 다릅니다.

#### HTML: 구조화된 마크업 언어

- HTML은 '의미론적 구조(Semantic Structure)'를 가집니다. `<h1>`은 제목, `<p>`는 단락이라는 명확한 의미가 있으며, 브라우저는 이 구조를 해석하여 화면 크기에 맞게 유동적으로 내용을 배치(Flow Layout)합니다.

```html
<article>
  <h1>제목</h1>
  <p>첫 번째 단락입니다.</p>
  <p>두 번째 단락입니다.</p>
</article>
```

#### PDF: 페이지 기반 문서 포맷

PDF는 "이 좌표에, 이 폰트로, 이 텍스트를 그려라"는 '**그리기 명령어**'들의 집합입니다. 
- 의미론적 구조보다는 어떤 디바이스에서도 동일하게 보이는 '시각적 표현'에 집중합니다. 
- 모든 요소는 절대 좌표를 기반으로 한 **고정 레이아웃(Fixed Layout)**을 가집니다.

```text
BT
/F1 12 Tf
72 720 Td
(제목) Tj
0 -24 Td
(첫 번째 단락입니다.) Tj
ET
```

### PDF의 내부 구조 들여다보기

HTML의 **DOM이 명확한 트리 구조**라면, PDF는 **객체들이 서로를 참조하는 복잡한 그래프 구조**를 가집니다.

**PDF 객체 구조**
- PDF는 Catalog (문서 전체 정보), Pages (페이지 트리), Page (개별 페이지 정보) 등 여러 객체들이 번호(e.g., 2 0 R)를 통해 서로를 비선형적으로 참조합니다.

```text
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj

2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj

3 0 obj
<< /Type /Page /Parent 2 0 R /Contents 4 0 R >>
endobj
```


**콘텐츠 스트림의 복잡성**
- HTML에서는 텍스트가 `<p>안녕하세요</p>` 처럼 통으로 존재하지만, PDF의 실제 내용은 Contents 객체 안의 스트림(Stream)에 명령어 형태로 분산되어 있습니다.

```text
BT
/F1 12 Tf      % 폰트 F1을 12pt 크기로 설정
100 700 Td     % (100, 700) 좌표로 이동
(안) Tj         % "안" 출력
6 0 Td         % x축으로 6만큼 이동
(녕) Tj         % "녕" 출력
...
ET
```

"안녕하세요"라는 하나의 단어를 재구성하려면, 각 글자의 그리기 명령어와 좌표를 모두 해석하고 조합해야 합니다.

## PDF 파서 개발이 어려운 이유

정리하자면, PDF의 아래와 같은 구조적 특징으로 PDF 형식의 자료를 다루는 것은 쉽지가 않습니다.

1. 구조적 복잡성

- 비선형적 데이터 구조: 파서는 문서의 전체 구조를 파악하기 위해 객체 참조를 따라 무작위로 파일을 읽어야 합니다.
- 압축과 인코딩: 콘텐츠 스트림은 FlateDecode(zlib) 등 다양한 방식으로 압축되어 있어, 파싱하려면 먼저 압축을 해제해야 합니다. HWnF}... 와 같은 데이터를 보고 바로 내용을 알 수 없는 이유입니다.
- 폰트 임베딩 문제: PDF는 폰트를 파일 내에 포함(임베딩)할 수 있습니다. 이때 'A'라는 문자를 유니코드가 아닌, 해당 폰트에서만 사용하는 내부 코드(\01)로 저장하기도 합니다. 파서는 이 내부 코드와 실제 문자를 매핑하는 ToUnicode 테이블을 해석해야 글자가 깨지는 것을 막을 수 있습니다.

2. 표준의 다양성과 호환성 이슈

- PDF는 1.0부터 2.0까지 여러 버전이 존재하며, 제조사별 비표준 확장 기능도 많습니다. 심지어 많은 PDF 파일들이 표준을 완벽히 지키지 않거나 일부 손상되어 있습니다. 
- 웹 브라우저가 깨진 HTML을 너그럽게 보여주듯, 좋은 PDF 파서는 이런 비표준적이거나 손상된 파일도 최대한 복구해서 처리할 수 있어야 합니다.

3. 레이아웃 복원의 어려움

- 파싱의 가장 큰 도전은 절대 좌표에 흩어진 텍스트 조각들로부터 논리적인 구조(문단, 표 등)를 추론해내는 것입니다.
- 텍스트 블록 인식: 수직 좌표(y) 값의 변화를 분석하여 어디서 문단이 시작되고 끝나는지 추론해야 합니다.
- 표 구조 파악: 수평(x) 및 수직(y) 좌표를 정렬하고 분석하여, 어떤 텍스트들이 같은 행(row)과 열(column)에 속하는지 파악하고 표의 구조를 재구성해야 합니다.

하지만 이게 끝이 아닙니다. PDF 데이터를 다룰 때에는 보안과 관련된 사항도 반드시 고려해야 합니다.

## PDF 파싱 시 보안 고려사항

PDF는 단순한 문서가 아닙니다. 실행 가능한 코드를 포함할 수 있어 서버 측에서 처리할 때 심각한 보안 위험을 초래할 수 있습니다.

### PDF의 보안 위험요소

- JavaScript 실행: PDF는 문서를 열거나 특정 동작을 할 때 JavaScript를 실행할 수 있습니다. 악의적인 스크립트가 포함된 PDF를 서버에서 파싱하면, 시스템 명령 실행이나 내부 네트워크 공격(SSRF)으로 이어질 수 있습니다.
- 임베디드 파일 및 외부 리소스: PDF 내부에 악성 실행 파일(virus.exe)을 숨기거나, 데이터를 탈취하기 위한 외부 URL(http://malicious-site.com)을 참조할 수 있습니다.
- 폼 필드와 액션: PDF 폼(Form)의 제출(Submit) 액션을 이용해 서버의 내부 정보를 외부로 전송하도록 조작할 수 있습니다.

메모리 및 리소스 관리
- 압축 폭탄 (ZIP Bomb): 1MB짜리 작은 PDF 파일이 압축을 해제하면 수 GB의 메모리를 소모하도록 만들어 서버 리소스를 고갈시키는 공격이 가능합니다.
- 무한 루프: 1 -> 2, 2 -> 1처럼 객체 참조가 순환되도록 만들어 파서를 무한 루프에 빠뜨릴 수 있습니다.

### 안전한 파싱을 위한 전략

서버에서 PDF를 처리할 때는 반드시 '샌드박싱(Sandboxing)' 개념을 적용해야 합니다.
- 리소스 제한: 파일 크기, 메모리 사용량, 처리 시간을 제한하여 리소스 고갈 공격을 방지합니다.
- 기능 비활성화: 가장 중요합니다. 사용하는 파서 라이브러리에서 JavaScript 실행 기능을 반드시 비활성화해야 합니다.
- 격리된 환경: Docker와 같이 격리된 환경에서 파싱을 수행하여, 문제가 생기더라도 호스트 시스템에 영향을 주지 않도록 합니다.


## 마무리
PDF 파싱은 겉보기와 달리 매우 복잡하고 깊이 있는 작업입니다. HTML과 달리 시각적 표현에 최적화된 포맷이기에 논리적 구조를 추출하기 어렵고, 다양한 보안 위협까지 내포하고 있습니다. 

이러한 이유로 저는 PDF parsing 기능은 Upstage 등에서 제공하는 SaaS를 쓰거나, LLM에게 요청하는게 합리적이라 판단해 해당 방식으로 필요 기능을 구현했습니다.

요약:
- PDF는 절대 좌표 기반의 고정 레이아웃 시스템을 사용
- 텍스트와 그래픽은 그리기 명령어 형태로 저장되어 의미론적 구조가 없음
- 다양한 압축, 인코딩, 폰트 처리로 인해 파싱이 복잡함
- JavaScript, 외부 리소스 참조 등으로 인한 심각한 보안 위험이 존재
- 안전한 처리를 위해 적절한 리소스 제한과 기능 비활성화, 샌드박싱은 선택이 아닌 필수임

