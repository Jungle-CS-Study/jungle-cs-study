# Java 21 Virtual Thread

## *‘Virtual Thread에 대해서 설명해주세요’*

Virtual Thread가 Java 21에 도입되면서, 최근 자바 백엔드 개발자 면접에서 자주 등장하는 질문입니다. 위 질문에 대한 간단한 답변은 아래와 같이 할 수 있습니다.

> "Virtual Thread는 Java 19에서 프리뷰로 도입되고 Java 21에서 정식 기능이 된 경량 스레드입니다. 기존 Platform Thread보다 메모리 사용량이 적고, 수백만 개까지 생성할 수 있어서 동시성 성능이 향상됩니다."
> 

## 그런데 정말 "왜" Virtual Thread가 필요했을까요?

지금까지 Thread Pool로도 충분히 동시성 처리를 해왔는데, 굳이 새로운 개념을 도입해야 할 이유가 있을까요? 기존 멀티스레딩 방식에 무슨 문제가 있었던 걸까요?

그리고 "Virtual Thread를 언제 사용해야 하는지"에 대한 명확한 기준을 알고 계신가요? 단순히 "성능이 좋아진다"는 추상적인 설명을 넘어서, 실제로 어떤 상황에서 도입을 검토해야 하는지 구체적인 판단 기준을 가지고 계신가요?

이번 글에서는 Virtual Thread의 탄생 배경부터 실무 적용 가이드라인까지, 차근 차근 짚어보겠습니다.

## OS와 JVM, 두 세계의 차이점

Virtual Thread를 이해하기 위해서는 먼저 **"누가 스레드를 관리하느냐"**라는 관점에서 접근해야 합니다. 이를 이해하기 위해 식당 운영 시스템에 비유해보겠습니다.

### Platform Thread: OS가 관리하는 "정규직 웨이터"

기존의 Platform Thread는 마치 식당에서 **정규직 웨이터를 고용하는 것**과 같습니다.

운영체제(식당 사장)가 직접 각 웨이터(스레드)를 관리하며, 웨이터 한 명당 고정된 급여(메모리)를 지급해야 합니다. 보통 웨이터 한 명은 **약 2MB의 스택 메모리**를 할당받습니다. 이는 마치 각 웨이터에게 개인 사물함을 제공하는 것과 같습니다.

웨이터가 쉬고 있을 때(I/O 대기 상태)에도 여전히 급여는 나가고, 사물함 공간도 계속 차지합니다. 또한 웨이터들 사이의 업무 교대(컨텍스트 스위칭)에는 상당한 시간이 소요됩니다. 사장(OS)이 직접 각 웨이터의 상태를 확인하고, 누가 어떤 테이블을 담당할지 결정해야 하기 때문입니다.

### Virtual Thread: JVM이 관리하는 "아르바이트 웨이터"

반면 Virtual Thread는 **아르바이트 웨이터 시스템**과 같습니다.

JVM(매니저)이 운영체제와 개별 가상 스레드 사이에서 중간 관리자 역할을 합니다. 실제로는 소수의 정규직 웨이터(Platform Thread)만 고용하고, 필요에 따라 수많은 아르바이트 웨이터(Virtual Thread)를 유연하게 배치합니다.

아르바이트 웨이터는 **몇 KB 정도의 작은 공간**만 있으면 됩니다. 개인 사물함이 아닌 공용 라커를 효율적으로 나누어 사용하는 방식입니다. 또한 매니저가 직접 아르바이트들의 업무를 조율하므로, 사장(OS)은 소수의 정규직 관리에만 신경쓰면 됩니다.

가장 중요한 점은 **아르바이트 웨이터가 잠시 쉬어야 할 때**(I/O 대기), 다른 아르바이트가 즉시 그 자리를 대신할 수 있다는 것입니다. 정규직 웨이터는 자리를 비우면 그 자리가 그대로 공석이 되지만, 아르바이트 시스템에서는 **한정된 인력으로 더 많은 고객을 효율적으로 서빙**할 수 있습니다.

그렇다면 이런 차이가 왜 중요해졌을까요? 현대의 식당(웹 애플리케이션)은 과거와는 완전히 다른 환경에 직면하고 있기 때문입니다.

## 기존 스레드 모델의 한계와 Virtual Thread의 등장 배경

### 현대 웹 애플리케이션의 특성 변화

과거의 웹 애플리케이션은 마치 **동네 작은 식당**과 같았습니다. 손님이 적고, 주문도 단순했습니다. 정규직 웨이터 몇 명이면 충분히 운영할 수 있었죠.

하지만 현대의 웹 애플리케이션은 **대형 푸드코트**가 되었습니다. 수천, 수만 명의 손님이 동시에 몰려들고, 각자 다른 매장에서 주문하며, 배달 주문까지 처리해야 합니다. 더 중요한 것은 대부분의 주문 처리 시간이 **"대기 시간"**이라는 점입니다.

### I/O 중심 작업의 증가

현대 백엔드 애플리케이션에서 스레드가 하는 일의 대부분은 다음과 같습니다:

- 데이터베이스 쿼리 결과 대기
- 외부 API 호출 응답 대기
- 파일 시스템 접근 대기
- 네트워크 통신 대기

이는 마치 웨이터가 주방에서 요리가 완성되기를 기다리거나, 다른 매장에서 음식을 가져오기를 기다리는 것과 같습니다. **실제 일하는 시간보다 기다리는 시간이 훨씬 많다**는 뜻입니다.

### Thread Pool의 한계

기존 방식에서는 이 문제를 Thread Pool로 해결하려 했습니다. 정규직 웨이터를 미리 여러 명 고용해두고, 주문이 들어오면 순서대로 배정하는 방식이었죠.

하지만 **C10K 문제**(동시 연결 1만 개 처리)가 대두되면서 이 방식의 한계가 명확해졌습니다. 웨이터를 1만 명 고용할 수는 없습니다. 급여(메모리)만으로도 식당이 망할 것입니다.

```
1만 개 Platform Thread = 약 20GB 메모리 사용
(각 스레드당 2MB × 10,000개)
```

게다가 웨이터가 너무 많으면 서로 부딪히고(컨텍스트 스위칭 오버헤드), 사장(OS)이 관리하기도 어려워집니다.

### 기존 해결책들의 한계

이 문제를 해결하기 위해 다양한 방법들이 시도되었습니다:

**1. Reactive Programming (Spring WebFlux)**
마치 "무인 주문 키오스크"를 도입한 것과 같습니다. 웨이터가 직접 대기하지 않고, 주문이 완성되면 알림을 받아 처리하는 방식입니다. 효율적이지만 **기존 웨이터들(개발자들)이 완전히 새로운 업무 방식을 익혀야** 했습니다.

**2. Async/Await 패턴**
웨이터가 주문을 받고 다른 일을 하다가, 요리가 완성되면 돌아와서 서빙하는 방식입니다. 하지만 **코드 복잡성이 크게 증가**했습니다.

이러한 해결책들은 분명 효과적이었지만, **기존 코드와의 호환성 문제**와 **학습 곡선의 가파름**이라는 단점이 있었습니다.

### Virtual Thread의 혁신적 접근

Virtual Thread는 완전히 다른 접근을 했습니다. "웨이터 업무 방식은 그대로 두되, 관리 시스템만 바꾸자"는 것이었습니다.

기존 동기식 코드는 전혀 수정하지 않으면서도, JVM 레벨에서 스레드 관리 방식을 개선했습니다. 개발자는 여전히 익숙한 방식으로 코드를 작성하지만, 내부적으로는 수백만 개의 경량 스레드가 효율적으로 동작합니다.

이는 마치 "웨이터들은 기존 방식대로 일하되, 뒤에서 AI 매니저가 모든 것을 효율적으로 조율해준다"는 개념입니다.

그렇다면 이러한 Virtual Thread를 언제 도입해야 할까요? 모든 상황에서 Virtual Thread가 항상 최고의 선택일까요?

## Virtual Thread 도입이 적절한 경우

Virtual Thread가 아무리 혁신적이라 해도, **모든 식당에서 아르바이트 시스템이 효과적인 것은 아닙니다.** 식당의 특성과 상황에 따라 적합한 운영 방식이 다르기 때문입니다.

### I/O 집약적 vs CPU 집약적 작업

**I/O 집약적 작업: "배달 전문 식당"**

주문을 받으면 대부분의 시간을 외부 업체(데이터베이스, API)에서 음식을 가져오는 데 사용하는 식당입니다. 웨이터는 주문을 넣고 음식이 올 때까지 **대기 시간이 매우 깁니다.**

이런 상황에서는 아르바이트 시스템(Virtual Thread)이 매우 효과적입니다. 한 명이 기다리는 동안 다른 아르바이트가 새로운 주문을 받을 수 있기 때문입니다.

- 웹 API 서버 (외부 서비스 호출이 많은 경우)
- 마이크로서비스 아키텍처 (서비스 간 통신이 빈번한 경우)
- 데이터베이스 쿼리가 많은 애플리케이션

**CPU 집약적 작업: "주방에서 직접 요리하는 식당"**

주문을 받으면 웨이터가 직접 주방에서 **복잡한 요리를 만드는** 식당입니다. 실제 요리하는 시간이 대부분이고, 대기 시간은 거의 없습니다.

이런 경우에는 정규직 웨이터(Platform Thread) 시스템이 더 효율적일 수 있습니다. 아르바이트를 아무리 많이 고용해도, 결국 주방(CPU)의 처리 능력이 병목이 되기 때문입니다.

- 이미지/동영상 처리
- 복잡한 수학 연산
- 암호화/복호화 작업

### 구체적인 적용 시나리오

**도입을 적극 검토해야 하는 경우:**

1. **MSA 환경에서 서비스 간 통신이 빈번한 경우**
    - 한 번의 사용자 요청이 여러 마이크로서비스를 거쳐야 하는 상황
    - 각 호출마다 네트워크 대기 시간이 발생
2. **대용량 트래픽 처리가 필요한 경우**
    - 동시 접속자가 많은 서비스
    - 실시간성이 중요한 API 서버
3. **외부 API 의존성이 높은 경우**
    - 결제, 인증, 알림 등 외부 서비스 호출이 많은 시스템
    - 각 외부 호출마다 수백 밀리초의 대기 시간 발생

**신중하게 고려해야 하는 경우:**

1. **CPU 집약적 작업이 주를 이루는 경우**
    - 이미지 처리, 암호화, 복잡한 계산 등
2. **Thread Local 변수를 많이 사용하는 경우**
    - Virtual Thread는 매우 많이 생성되므로 메모리 사용량 증가 가능
3. **Synchronized 블록이 많은 레거시 코드**
    - Virtual Thread가 Platform Thread에 고정될 수 있어 성능 이점 감소

### 성능 측정과 점진적 도입

Virtual Thread 도입은 **"ALL or NOT"의 선택이 아닙니다.** 마치 식당에서 바쁜 시간대에만 아르바이트를 추가로 고용하는 것처럼, 특정 작업에만 선별적으로 적용할 수 있습니다.

**단계별 도입 전략:**

1. **성능 테스트 환경에서 검증**
2. **특정 API 엔드포인트부터 시작**
3. **모니터링을 통한 성능 비교**
4. **점진적 확대 적용**

이처럼, "Virtual Thread는 만능 해결책이 아니라, 특정 상황에 특화된 도구"라는 것을 명심하며, 문제 상황에 맞게 적절히 도입하는 것이 중요합니다.

## 마무리: 동시성 프로그래밍의 새로운 패러다임

Virtual Thread의 등장은 단순한 성능 개선이 아닌, **자바 동시성 프로그래밍의 패러다임 변화**를 의미합니다. 복잡한 비동기 프로그래밍 없이도 고성능 동시성 처리가 가능해졌고, 기존 코드와의 호환성을 유지하면서도 현대적 요구사항을 충족할 수 있게 되었습니다.

하지만 가장 중요한 것은 "언제, 왜 사용해야 하는지"에 대한 명확한 이해입니다. Virtual Thread는 I/O 집약적 작업에서 빛을 발하는 도구이며, 모든 상황의 만능 해결책은 아닙니다.

현대 백엔드 개발자에게 동시성 처리 능력은 선택이 아닌 필수입니다. Virtual Thread의 등장으로 이 영역의 진입 장벽이 크게 낮아졌지만, 여전히 **각 도구의 특성과 적용 시점을 정확히 이해하는 것**이 핵심입니다.

---

**이제 아래의 3개의 면접질문에 답해보세요!**

1. **"Platform Thread와 Virtual Thread의 가장 결정적인 차이를 OS 레벨과 JVM 레벨에서 설명해주시겠어요?"**
2. **"Java에 Virtual Thread가 도입된 근본적인 이유가 무엇이라고 생각하시나요? 기존 스레드 모델의 어떤 점을 해결하기 위해서였을까요?"**
3. **"Virtual Thread는 어떠한 때에 도입하는게 적절하다고 생각하세요? 구체적인 근거와 함께 말해주세요."**

지금까지의 내용을 참고하여 여러분만의 답변을 준비해보시기 바랍니다.