기술면접 대비 AI 서비스를 최근 만들다보니, 이번 주부터는 실제 기술면접 질문 답변 암기를 넘어, 실질적으로 이해하기 위한 글을 작성해보기로 했습니다. 

이번 주 글의 세부 주제는 ‘HTTP Method’입니다. 지금부터 글 시작하겠습니다!

# HTTP 메소드를 왜 구분해서 사용해야 할까?

## 기술면접 단골 질문

> "HTTP Method와 각각이 사용되는 경우에 대해서 설명해주세요."
> 

이 질문은 웹 백엔드 개발자 기술면접에서 빠지지 않는 단골 질문입니다. 대부분의 개발자들은 이렇게 답변합니다.

<aside>
💡

- **GET**: 데이터를 조회할 때 사용합니다
- **POST**: 새로운 데이터를 생성할 때 사용합니다
- **PUT**: 기존 데이터를 수정할 때 사용합니다
- **DELETE**: 데이터를 삭제할 때 사용합니다
</aside>

틀린 답변은 아닙니다. 하지만 이 답변을 듣고 나면 자연스럽게 다음 질문이 따라옵니다.

## 그런데 정말 "왜" 구분해서 써야 할까요?

실제로 개발을 하다 보면 이런 생각이 들 때가 있습니다. 사용자 정보를 조회하든, 게시글을 작성하든, 댓글을 삭제하든 - 결국 모든 기능을 POST 메소드 하나로도 충분히 구현할 수 있지 않을까요?

```jsx
// 이렇게 POST 하나로 모든 걸 처리할 수 있는데...
POST /api/user/get     // 사용자 조회
POST /api/user/create  // 사용자 생성
POST /api/user/update  // 사용자 수정
POST /api/user/delete  // 사용자 삭제
```

그렇다면 **"POST 메소드 하나로도 모든 CRUD 기능을 구현할 수 있는데, 왜 굳이 GET, PUT, DELETE 등의 메소드를 구분해서 사용해야 하나요?"**

이 질문에 대한 명확한 기술적 근거를 아시나요? 단순히 "REST API 설계 원칙이니까"라는 답변을 넘어서, 실제로 어떤 기술적 차이가 발생하는지 알고 계신가요?

이 글에서는 HTTP 메소드를 구분해서 사용해야 하는 **이론적 근거와 실제 동작 원리**를 깊이 있게 살펴보겠습니다.

## Semantic HTTP methods의 중요성

일상 대화에서 의미 구분이 얼마나 중요한지 생각해보겠습니다. 친구에게 "책 좀 줘"라고 말할 때와 "책 좀 빌려줘"라고 말할 때, 단어 몇 개만 다를 뿐이지만 의미는 완전히 다릅니다. 전자는 소유권이 이전되지만, 후자는 임시로 빌리는 것이죠.

HTTP 메소드도 마찬가지입니다. 서버에게 "이 데이터를 달라(GET)"고 말하는 것과 "이 데이터를 만들어줘(POST)"라고 말하는 것은 **문법적으로는 비슷하지만 의미적으로는 완전히 다른 요청**입니다.

```
GET /api/users/123     // "사용자 123번 정보를 보여줘"
POST /api/users        // "새로운 사용자를 만들어줘"
PUT /api/users/123     // "사용자 123번 정보를 이것으로 바꿔줘"
DELETE /api/users/123  // "사용자 123번을 삭제해줘"
```

### 왜 의미적 구분이 중요할까?

웹은 단순히 두 컴퓨터가 대화하는 공간이 아닙니다. **수많은 중간 시스템들**(프록시 서버, CDN, 캐시 서버, 로드밸런서 등)이 이 대화를 듣고 있으며, 각각 다른 방식으로 반응합니다.

마치 우체국 직원이 편지봉투에 적힌 "긴급", "일반우편", "등기우편" 같은 표시를 보고 서로 다른 처리 방식을 적용하는 것과 같습니다. 만약 모든 편지봉투에 "그냥 편지"라고만 적혀 있다면, 우체국은 어떤 편지를 우선 처리해야 할지, 어떤 편지를 안전하게 보관해야 할지 알 수 없을 것입니다.

HTTP 메소드는 바로 이런 **"처리 방식을 알려주는 표시"** 역할을 합니다. 그렇다면 각 메소드가 가진 구체적인 특성들이 실제로 어떤 기술적 차이를 만들어내는지 살펴보겠습니다.

## 표준 메소드 사용의 기술적 및 아키텍처적 이점

표준 HTTP 메소드를 의미에 맞게 사용하는 것은 단순히 멋있어 보이기 위함이 아닙니다. 실제 시스템 개발, 운영, 유지보수 전반에 걸쳐 엄청난 이점을 제공합니다.

### 안전성과 멱등성: 단순한 개념이 아닌 기술적 약속

HTTP 메소드를 구분하는 가장 중요한 기준은 **안전성(Safe)**과 **멱등성(Idempotent)**입니다. 이 개념들이 단순한 이론이 아닌 실제 시스템 동작에 어떤 영향을 미치는지 살펴보겠습니다.

**안전한(Safe) 메소드:** 서버의 상태를 변경하지 않는 메소드

**멱등한(Idempotent) 메소드:** 동일한 요청을 여러 번 보내도 결과가 같은 메소드

| HTTP 메소드 | 안전성 (Safe) | 멱등성 (Idempotent) | 설명 |
| --- | --- | --- | --- |
| GET | ✅ 안전함 | ✅ 멱등함 | 데이터 조회만 수행, 상태 변경 없음 |
| POST | ❌ 안전하지 않음 | ❌ 멱등하지 않음 | 새 리소스 생성, 매번 다른 결과 |
| PUT | ❌ 안전하지 않음 | ✅ 멱등함 | 전체 리소스 교체, 같은 값으로 반복 시 동일 결과 |
| PATCH | ❌ 안전하지 않음 | ❓ 경우에 따라 다름 | 부분 수정, 구현 방식에 따라 멱등성 결정 |
| DELETE | ❌ 안전하지 않음 | ✅ 멱등함 | 리소스 삭제, 이미 없는 것 삭제해도 동일 결과 |

하지만 여기서 중요한 점은, **HTTP 메소드 자체가 이런 특성을 강제하는 것이 아니라는 것**입니다. 개발자는 GET으로도 데이터를 삭제하는 API를 만들 수 있고, POST로도 단순 조회 API를 만들 수 있습니다.

```jsx
// 기술적으로는 가능하지만 잘못된 사용
app.get('/api/users/123/delete', (req, res) => {
    // GET인데 데이터를 삭제하는 로직
    database.deleteUser(123);
    res.json({success: true});
});
```

핵심은 **웹의 중간 계층들(브라우저, 캐시 서버, 프록시 등)이 HTTP 명세를 믿고 동작한다**는 것입니다.

### 명확성 및 가독성

API Endpoint만 봐도 이 요청이 어떤 작업을 하려는 건지 명확히 알 수 있습니다.

```
GET /api/users/123      # "123번 사용자 정보를 읽어오겠구나"
DELETE /api/users/123   # "123번 사용자를 삭제하겠구나"
```

반면 POST 요청 하나로 모든 작업을 처리한다면, 요청 본문이나 별도의 파라미터를 열어보기 전에는 이게 회원 가입인지, 로그인인지, 정보 수정인지, 탈퇴인지 알 수가 없습니다. 이는 개발자 간 협업과 코드 이해도를 크게 저해합니다.

### 캐싱: 성능 최적화의 핵심

HTTP 메소드 구분이 가장 극명하게 드러나는 영역은 **캐싱**입니다.

우체국에서 자주 배달되는 주소는 따로 기억해두듯이, 웹에서도 자주 요청되는 데이터는 중간 지점에 저장해둡니다. 하지만 모든 요청을 캐시할 수는 없습니다.

```
# 캐시 가능한 요청들
GET /api/users/123           # 브라우저, CDN에서 자동 캐시
GET /api/products?page=1     # 자주 조회되는 상품 목록 캐시

# 캐시하면 안 되는 요청들
POST /api/users              # 매번 새로운 사용자가 생성됨
POST /api/orders             # 매번 새로운 주문이 발생함
```

**GET 요청만 기본적으로 캐시 대상**이 됩니다. 이는 HTTP 명세에서 정의한 동작이며, 모든 브라우저, CDN, 프록시 서버가 따르는 규칙입니다. 이러한 HTTP 캐싱 메커니즘을 활용하면 서버 부하를 획기적으로 줄이고 응답 속도를 높여 사용자 경험을 개선할 수 있습니다.

### 보안(Security)

각 메소드의 특성에 맞는 보안 정책을 적용하기 용이합니다. 예를 들어, 방화벽이나 API 게이트웨이에서 특정 자원에 대해 GET 요청(조회)만 허용하고 PUT이나 DELETE 요청은 차단하는 정책을 쉽게 설정할 수 있습니다.

```bash
# API 게이트웨이에서 메소드별 보안 정책
location /api/public/ {
    # 공개 API는 GET만 허용
    limit_except GET {
        deny all;
    }
    proxy_pass http://backend;
}

location /api/admin/ {
    # 관리자 API는 모든 메소드 허용 (인증 후)
    auth_basic "Admin Area";
    proxy_pass http://backend;
}
```

메소드를 구분함으로써 이러한 보안 고려사항을 체계적으로 적용할 수 있습니다.

### 네트워크 인프라 활용

프록시 서버, 로드밸런서, API 게이트웨이 등 다양한 네트워크 구성 요소들은 HTTP 메소드를 인지하고 그에 맞춰 동작을 최적화하거나 보안 정책을 적용합니다.

실무에서 여러 서버를 운영할 때 사용하는 로드밸런서도 HTTP 메소드를 다르게 처리합니다.

```bash
# Nginx 로드밸런서 설정 예시
upstream backend {
    server app1.example.com;
    server app2.example.com;
}

# GET 요청은 모든 서버로 분산 가능
location ~ ^/api/.*/$ {
    if ($request_method = GET) {
        proxy_pass http://backend;
    }
}

# POST 요청은 세션 어피니티 고려
location /api/orders {
    if ($request_method = POST) {
        proxy_pass http://backend;
        # 같은 사용자는 같은 서버로 라우팅
    }
}
```

GET 요청은 어느 서버에서 처리하든 결과가 동일하므로 자유롭게 분산시킬 수 있지만, POST 요청은 서버 상태를 변경하므로 더 신중한 라우팅이 필요합니다.

### 상호운용성 및 확장성

표준을 준수하는 API는 다른 시스템과의 통합이 매우 용이합니다. 잘 정의된 인터페이스는 계약과 같아서, 클라이언트와 서버가 서로의 구현을 몰라도 약속된 규칙에 따라 통신할 수 있습니다.

이는 마이크로서비스 아키텍처와 같이 분산된 시스템 환경에서 특히 중요하며, 미래에 기능이 확장되거나 시스템 일부가 교체될 때 유연하게 대처할 수 있게 합니다.

이처럼 HTTP 메소드 구분은 단순한 개발자 컨벤션이 아닌, **웹 인프라 전반에 걸친 기술적 표준**입니다.

## 면접 질문으로 다시 돌아가서

자, 이제 처음에 던진 그 질문으로 돌아가 보겠습니다.

> **"POST 메소드 하나로도 모든 CRUD 기능을 구현할 수 있는데, 왜 굳이 GET, PUT, DELETE 등의 메소드를 구분해서 사용해야 하나요?"**
> 

이 질문에 대한 답변을 지금까지 살펴본 내용을 바탕으로 정리해보겠습니다.

### 기술면접 모범 답변

<aside>
💡

**"네, 기술적으로는 POST 하나로도 모든 기능 구현이 가능합니다. 하지만 HTTP 메소드를 구분해서 사용해야 하는 이유는 크게 다섯 가지입니다.**

**첫째, 웹 인프라의 최적화 활용입니다.** GET 요청은 브라우저, CDN, 프록시 서버에서 자동으로 캐싱되어 성능 향상과 서버 부하 감소 효과를 얻을 수 있습니다. 또한 로드밸런서에서 메소드별로 다른 라우팅 전략을 적용할 수 있어 시스템 안정성이 높아집니다.

**둘째, 보안 정책의 체계적 적용입니다.** 메소드별로 서로 다른 보안 규칙을 설정할 수 있습니다. 예를 들어 API 게이트웨이에서 공개 엔드포인트는 GET만 허용하고, 관리자 기능은 인증 후 모든 메소드를 허용하는 식으로 세밀한 접근 제어가 가능합니다.

**셋째, 개발 생산성과 유지보수성입니다.** API 엔드포인트만 봐도 해당 요청의 의도를 즉시 파악할 수 있어 개발자 간 협업 효율성이 크게 향상됩니다. POST 하나로 모든 기능을 처리하면 요청 본문을 열어봐야만 무슨 작업인지 알 수 있어 코드 가독성이 떨어집니다.

**넷째, 안전성과 멱등성을 통한 신뢰성 확보입니다.** 각 메소드의 특성을 지키면 예상치 못한 부작용을 방지할 수 있습니다. 특히 GET은 서버 상태를 변경하지 않고, PUT과 DELETE는 동일한 요청을 여러 번 보내도 결과가 같아서 시스템의 예측 가능성이 높아집니다.

**다섯째, 상호운용성과 확장성입니다.** 표준을 준수하는 API는 다른 시스템과의 연동이 용이하고, 미래에 시스템이 확장되거나 일부가 교체될 때도 유연하게 대응할 수 있습니다.

**결론적으로, HTTP 메소드 구분은 현재의 기능 구현뿐만 아니라 장기적인 시스템 운영과 확장을 고려한 아키텍처 설계의 핵심 요소입니다."**

</aside>

이제 여러분도 **"*왜 HTTP 메소드를 구분해야 하는가?*"**라는 질문에 대해 단순한 암기가 아닌, 실제 동작 원리를 바탕으로 한 깊이 있는 답변을 할 수 있을 것입니다.

기술면접에서 이런 질문을 받는다면, 자신 있게 답변해보세요!