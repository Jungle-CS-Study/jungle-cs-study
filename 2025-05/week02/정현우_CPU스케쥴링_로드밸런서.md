### 도입: "로드 밸런서와 CPU 스케줄링, 전혀 다른 얘기 아니야?"

웹 개발을 하다 보면 '로드 밸런서'라는 용어를 자주 만나게 됩니다. 일반적으로는 “트래픽을 여러 서버에 나눠주는 장치” 정도로 이해하지만, 이 개념은 운영체제에서 배운 CPU 스케줄링과 꽤 닮아 있습니다.

두 개념이 다루는 분야는 달라 보이지만, 공통적으로 \*\*'제한된 자원을 어떻게 효율적으로 나눌 것인가'\*\*라는 고민을 담고 있습니다. 로드 밸런서는 사용자 요청이라는 트래픽을 여러 서버로 분배하고, CPU 스케줄러는 여러 프로세스에게 CPU 사용 기회를 분배합니다.

이 글에서는 CPU 스케줄링과 로드 밸런서를 연결해서 바라보며, **자원 분배에 대한 전략적 사고방식**을 정리해보고자 합니다.

---

### 시스템 자원은 왜 '전략적으로' 분배해야 할까?

자원을 전략적으로 분배한다는 개념은 단순한 공정함을 넘어섭니다. 예를 들어 도서관에 책이 한 권 있는데, 다섯 명이 동시에 읽고 싶어한다고 가정해보면 누구에게 먼저 줄 것인가에 따라 전체 효율이 달라집니다.

이처럼 분배 기준에 따라 전체 대기 시간이나 긴급도 충족 정도가 달라집니다. 이는 곧 **시스템 효율을 어떻게 극대화할 수 있을지에 대한 판단**과 연결됩니다.

웹 서비스도 마찬가지입니다. 서버 리소스는 유한하고, 요청은 동시에 몰려들 수 있습니다. 단순 무작위 분산보다는 요청의 특성이나 서버 상태를 고려한 **전략적인 분배**가 전체 응답 속도나 안정성에 더 유리합니다.

**전략적인 자원 분배는 시스템 전체 성능을 좌우할 수 있는 중요한 결정입니다.**

---

### CPU 스케줄링 알고리즘: 자원 분배의 원조

CPU 스케줄링은 운영체제에서 CPU라는 자원을 여러 프로세스에 나눠주는 방식입니다. 주요 알고리즘은 다음과 같습니다:

| 알고리즘                              | 설명                     | 장점               | 단점                                    |
| --------------------------------- | ---------------------- | ---------------- | ------------------------------------- |
| **FCFS (First Come First Serve)** | 먼저 도착한 순서대로 처리         | 구현이 단순하고 공정함     | 긴 작업이 앞에 오면 전체 대기 시간 증가 (Convoy 효과)   |
| **Round Robin**                   | 고정된 시간 단위로 CPU를 번갈아 할당 | 응답성이 좋고 공평한 분배   | 짧은 타임퀀텀일 경우 context switching 오버헤드 발생 |
| **SJF (Shortest Job First)**      | 짧은 작업을 먼저 처리           | 평균 대기 시간을 최소화    | 긴 작업이 계속 밀릴 수 있음 (Starvation)         |
| **Priority Scheduling**           | 우선순위가 높은 작업부터 처리       | 중요 작업을 빠르게 처리 가능 | 우선순위 낮은 작업이 무한정 지연될 수 있음 (Starvation) |

**스케줄링은 상황에 맞는 전략 선택이 핵심입니다.** 어떤 작업이 주로 발생하는가에 따라 적절한 스케줄링 전략이 달라지기 때문입니다.

---

### 로드 밸런서도 결국 '누구에게 먼저 보낼까'의 문제

로드 밸런서는 사용자 요청을 여러 서버에 분배합니다. 이때 사용하는 전략은 상황에 따라 다릅니다:

| 분산 전략                    | 설명                    | 유리한 상황           |
| ------------------------ | --------------------- | ---------------- |
| **Round Robin**          | 요청을 순차적으로 서버에 분배      | 요청 처리 시간이 비슷한 경우 |
| **Least Connections**    | 현재 연결 수가 적은 서버에 요청 전송 | 요청 처리 시간이 다양한 경우 |
| **IP Hash**              | 클라이언트 IP 기반으로 서버 고정   | 세션 유지를 위한 요청 분산  |
| **Weighted Round Robin** | 서버 성능에 따라 가중치 부여 후 분산 | 서버 성능이 다양한 경우    |

이 전략들은 CPU 스케줄링 알고리즘과 유사한 특징을 갖고 있습니다. Round Robin은 이름 그대로 동일하고, Least Connections는 SJF처럼 빠르게 끝날 가능성이 높은 서버를 우선 선택합니다. Weighted 방식은 Priority Scheduling처럼 리소스에 따라 우선순위를 부여하는 구조와 닮았습니다.

**요청의 특성에 따라 어떤 전략이 적절한지 달라진다는 것**이 핵심입니다. 분산 전략도 결국 **‘자원을 어떤 기준으로 나눌 것인가’에 대한 전략적 선택의 문제**입니다.

---

### CPU 스케줄링을 이해하면 로드 밸런서가 보인다

자원 분배를 어떻게 할 것인지에 대한 구조적 사고는 로드 밸런서를 이해하는 데에도 큰 도움이 됩니다.

**단순히 트래픽을 고르게 나눈다는 것이 아니라, 각 전략이 어떤 상황에 강점이 있는지를 알고 선택하는 것이 중요합니다.**

예를 들어, 서버 응답 속도가 느려졌을 때 단순히 서버 성능을 의심하기보다는, 현재의 분산 전략이 병목을 만들고 있지는 않은지 살펴볼 수 있습니다. 요청이 긴 작업 위주로 특정 서버에 몰린 것은 아닌지, 혹은 연결 수에 따른 분산이 적절히 이루어지고 있는지를 판단해야 합니다.

이처럼 스케줄링 개념은 **시스템을 '설정값'이 아니라 '정책'으로 바라보는 시각**을 길러줍니다.

---

### 마무리: 기술을 그냥 '사용'하지 않기 위해

CPU 스케줄링은 당장 웹 서비스에서 직접 사용할 기술은 아닐 수 있지만, **자원 분배에 대한 전략적 사고를 기르는 데 매우 유용한 개념입니다.**

로드 밸런서와 같은 인프라 구성 요소도 결국 자원을 효율적으로 나누기 위한 결정의 연속이기 때문입니다.

**기술을 단순히 '사용하는 것'에 머무르지 않고, 그 안에 담긴 구조와 전략을 이해하고 선택할 수 있어야 더 나은 시스템 설계와 운영이 가능해집니다.**
