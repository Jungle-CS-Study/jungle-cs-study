# 메모리는 꽉 찼는데, 왜 게임이 안터지지? : 가상 메모리(Virtual Memory)

면접을 보러 다녔을 때, `가상 메모리에 대해서 설명하세요.`라는 질문을 들은 적이 있다. 정글 끝나고 몇 달 안된 시점이었지만.. 가상 메모리에 대해서 깊이 있게 답변하지 못했었다. 이번 기회에, 가상 메모리가 무엇이고 왜 중요한지 정리해보자.

<br>

# 가상 메모리의 등장 배경 : 왜 필요했을까?

컴퓨터 시스템은 물리적인 한계가 존재한다. 동시에 실행되는 프로그램은 많다. 이 프로그램들은 모두 메모리 공간을 요구하는데, RAM의 용량은 유한하다. 만약에 프로그램들이 요구하는 램의 용량이 RAM의 용량보다 더 크다면, CPU는 모든 프로그램에게 필요한 만큼의 RAM 용량을 전달할 수 없다.

또, 서로 다른 프로그램이 같은 메모리 공간을 점유하게 될 경우, 충돌하거나 보안 문제가 발생할 수 있다.

이러한 문제들을 해결하기 위해서 **가상 메모리** 기법이 등장하게 되었다.

<br>

# 가상 메모리(Virtual Memory)에 대해서 알아보자.

가상 메모리는 운영체제(OS)가 물리적 메모리(RAM)의 한계를 극복하고 프로그램 실행에 필요한 메모리를 효과적으로 관리하기 위해 사용하는 메모리 관리 기법이다.

가상 메모리의 핵심 아이디어는 `프로그램이 직접 물리 주소를 다루는 것이 아니라, 가상의 넓은 메모리 공간`을 다루게 하는 것이다.

결과적으로 프로세스는 실제 메모리 용량과 상관 없이, 자신만의 큰 연속된 메모리 공간을 가지는 것 같은 `환상`을 줄 수 있다. 이로 인해서 프로세스가 다루는 메모리 주소는 항상 가상 주소(Virtual Address)를 의미하고 물리 메모리의 실제 위치를 나타내는 주소는 물리 주소(Physical Address)로 분리할 수 있다.

<br>

## 가상 주소에서 물리 주소로 : 주소 변환(Address Translation)

가상 메모리에서 주소 변환은 중요한 핵심 중 하나다. 가상 주소만을 가지고는 실제 메모리에 접근할 수 없기 때문이다. CPU가 데이터를 읽고 쓰기 위해서는 물리 주소가 필요한데, 이러한 변환 과정을 주소 변환(Address Translation)이라고 한다.

주소 변환은 하드웨어 장치 중 하나인 MMU(Memory Management Unit)가 담당한다. CPU가 생성한 가상 주소를 받고 이를 실제 메모리 주소로 변환하는 역할을 한다. 

주소 변환은 다음의 순서로 이루어진다.

1. 가상 주소를 페이지 번호와 페이지 오프셋으로 나눈다.
2. MMU는 페이지 번호를 페이지 테이블에서 찾아 대응하는 물리 프레임을 찾는다.
3. 물리 프레임 번호와 오프셋을 조합해 물리 주소를 생성한다.

<br>

# 페이징(Paging) : 가상 메모리를 불러오는 방법

운영체제는 가상 주소 공간을 실제 물리 메모리에 불러오는 기법으로 페이징(Paging) 기법을 사용한다. 페이징은 가상 주소 공간과 물리 주소 공간을 동일한 크기의 고정된 블록(Page) 단위로 쪼개어 관리하는 방법을 말한다.

덕분에 가상 주소 공간은 논리적으로 연속되어 있어도, 물리 메모리 상에는 페이지가 흩어져 존재할 수 있다.

<br>

## 페이지(Page)와 페이지 테이블(Page Table)

페이징 기법에서 사용하는 블록들은 페이지(Page)로 불린다. 보통 하나의 페이지 크기는 4KB, 8KB 정도 된다. 그리고 가상 주소 공간의 페이지와 물리 주소 공간의 매핑 정보를 저장하는 공간을 페이지 테이블(Page Table)이라고 하는데, 프로세스마다 독립된 페이지 테이블을 가지게 된다.

이 친구들의 관계를 조합하면 다음과 같은 구조를 가진다.

1. 페이지 테이블 : "어. 너 가상 메모리 주소구나?" -> 가상 페이지 번호를 통해서 페이지 테이블을 검사하고
2. 페이지 테이블 : "너랑 대응하는 물리 메모리 주소야." -> 대응하는 물리 메모리 주소를 계산한다.

<br>

## 폴트. 폴트. 페이지 폴트(Page Fault).

폴트(Fault)는 세그먼테이션 폴트를 시작으로 프로그래밍에서 많이 보이는 단어다. 페이징 기법에도 폴트가 존재하는데, 이 경우 페이지 폴트(Page Fault)라고 한다.

프로그램이 특정 주소에 실제로 접근하려고 했을 때, 해당 페이지가 메모리에 없으면 발생하게 된다.

이렇게 될 경우, 디스크에서 필요한 페이지를 읽어와 메모리에 적재하고 다시 프로세스 실행을 이어나간다.

<br>

## 빠른 주소 변환 : TLB(Translation Lookaside Buffer)

주소 변환을 할 때 마다, 페이지 테이블을 탐색하게 된다면 메모리 접근 속도가 느려질 수 있다. 이런 경우에 사용되는게 TLB(Translation Lookaside Buffer)라는 이름의 고속 캐시 메모리다.

TLB는 최근에 변환된 가상 주소 -> 물리 주소 매핑을 저장하고 있다. CPU가 같은 가상 주소를 다시 요청할 때, TLB를 통해서 빠르게 얻을 수 있다.

CPU가 원하는 주소가 TLB에 존재할 경우에는 TLB Hit, 아닐 때에는 TLB Miss라고 한다.
