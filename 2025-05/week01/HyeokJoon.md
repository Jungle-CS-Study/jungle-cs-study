# Virtual Memory And Paging

가상 메모리와 페이징 개념은 단순한 메모리 관리 기술을 넘어, 시스템 전반에서 자원의 효율적 활용과 추상화를 가능케 하는 핵심 원리로 확장될 수 있다. 이 문서에서는 각 소제목에 따라 기본적인 개념 설명과 함께 이를 다양한 분야로 확장하여 서술한다.

- 가상메모리를 사용하는 이유
- 페이징, 세그멘테이션을 사용하는 이유
- 중간 정리: 가상 메모리와 페이징의 본질적 개념
- Route53 : (가상메모리의 목적과의 유사성 관점)
- Virtual Thread


---

## 1. 가상 메모리를 사용하는 이유

### [초기 컴퓨터의 문제]
1. 메모리 용량이 너무 작아서, 물리적 메모리보다 큰 프로그램을 실행할 수 없다
2. 절대적인 물리적 메모리 주소를 사용함으로 인해, 모든 프로세스가 연속되지 않는 메모리 공간을 사용해야 했다
3. 물리적인 메모리 주소에 접근하기 때문에 다른 프로세스의 메모리 주소에도 접근할 수 있다.


### [해결 방안]
- 모든 데이터를 RAM에 올리지 않고, swap영역에 저장해두고 필요할 때 올려서 사용한다
- 메모리 관리 장치(MMU, Memory Management Unit)를 사용한 주소 변환을 통해 프로세스는 연속적인 가상 주소를 사용할 수 있게 된다.
- 가상 메모리 주소를 MMU변환을 통해 접근하기 때문에 다른 프로세스 메모리 주소 접근을 차단한다.

-> **가상메모리의 탄생**

### [가상 메모리의 근본적 개념]
**기본 개념**:  
> 실제 물리 메모리가 아닌 가상의 메모리 공간을 프로그램에 제공하는 추상화 기법.
> \
> 이를 통해 **메모리 관리 측면** 과 **메모리 보호 측면** 에서 장점을 가진다. 

**확장된 개념**:  
> 제한된 자원을 추상화하여 사용자에게 충분한 자원이 있는 것처럼 보이게 만드는 기법. 이는 네트워크 대역폭, 스토리지 등 다양한 자원에서 활용될 수 있다. 


---

## 2. 페이징, 세그멘테이션을 사용하는 이유

### [초기 가상메모리의 문제]
1. 하나의 주소에 접근할 때마다 Disk에 접근해서 로드하는 과정을 수행하게 되어 오버헤드가 커진다.

### [해결방법]

- 벌크 단위의 메모리 로드를 수행하도록 한다.

-> 페이징, 세그멘테이션 탄생

### [페이징의 근본적 개념]
**기본 개념**: 
> 가상 메모리를 고정된 크기(페이지)로 나누어, 메모리 단편화 방지 및 교체 용이성 확보

**확장된 개념**: 
> 큰 자원을 작고 일정한 단위로 분할하여 효율적으로 관리하고, 필요할 때만 사용하는 전략 (on-demand loading)

**예시 확장**:

    * 가상 스크롤링 / 무한 스크롤 UI
    * CDN에서 콘텐츠를 블록 단위로 분할 캐싱
    * 클라우드 객체 저장소(S3)의 멀티파트 업로드

---

## 3. 중간 정리: 가상 메모리와 페이징의 본질적 개념

* **가상 메모리**: 제한된 자원을 추상화하여 무제한처럼 보이게 하는 시스템 구조
* **페이징**: 이 추상화를 구현하기 위한 균일 단위의 분할과 동적 로딩 전략

> 이 두 개념은 자원 관리의 보편적 원리인 "**추상화 + 분할 관리**"의 대표적인 예시이며, 다양한 시스템 설계에 응용된다.

---

## 4. Route53 : (가상메모리의 목적과의 유사성 관점)

**Route 53의 도메인 매핑 및 독립적 DNS 설정 방식** : 
> Route 53에서 하나의 물리적 IP(VIP)를 기반으로 다양한 도메인 네임 (A 레코드, CNAME 등) 을 매핑
>
| 활용 목적               | 가상 메모리에서의 개념    | IT 인프라 유사 사례                     |
| ------------------- | --------------- | -------------------------------- |
| **제한된 자원 가상화 및 매핑** | 가상 주소 ↔ 물리 주소   | Route 53: 도메인 ↔ IP               |
| **자원 보호 및 격리**      | 주소 공간 분리, 접근 제어 | Route 53: 도메인별 독립 구성, 장애 격리      |

### [자원 관리 측면 – 가상화와 매핑]
가상 메모리는 모든 프로세스가 독립적인 메모리를 갖고 있는 것처럼 보이지만, 실제로는 제한된 물리 메모리에 가상 주소 → 물리 주소 매핑을 통해 접근한다.

이는 Route 53에서 하나의 물리적 IP(VIP)를 기반으로 다양한 도메인 네임 (A 레코드, CNAME 등) 을 매핑하는 구조와 유사하다.

예:
\
`a.example.com → 1.2.3.4`
\
`b.example.com → 1.2.3.4`\
클라이언트마다 도메인 이름은 다르지만 실제로는 같은 자원(서버)에 연결됨.

### [자원 보호 측면 – 접근 격리]
가상 메모리는 각 프로세스가 자신의 가상 주소 공간만 접근할 수 있도록 하여, 다른 프로세스의 메모리 침범을 방지한다.

Route 53도 도메인 단위의 격리와 연결로 인해, 어떤 특정 서브도메인에서 문제가 생겨도 전체 시스템에 영향을 주지 않도록 분리할 수 있다.

예:
\
`admin.example.com` 에서 장애 발생 시, 해당 레코드만 비활성화하면 되고
`user.example.com` 등 다른 도메인은 영향 없음.

> 로드밸런서를 사용하면 도메인마다 다른 방화벽 규칙, Health Check 규정을 가지게 할 수 있다.

---
## 5. Virtual Thread

자바 21부터 가상 스레드 개념이 추가되었다.  
가상 스레드란 무엇이고 어떻게 사용하는지, 어떤 장점이 있는지 알아보고자 한다.

### [Java Thread의 문제]
1. 쓰레드 당 메모리 소비가 크다:  
   Java의 기존 플랫폼 쓰레드(Platform Thread)는 OS 스레드를 wrapper 클래스로 감싸서 구현된 인스턴스이다.\
   따라서 운영 체제에서 관리하는 대규모 스레드 스택과 기타 리소스를 가지고 있고, 하나당 수백 KB의 스택 메모리를 할당받는다.
2. 컨텍스트 스위칭 비용이 높다
3. 블로킹 I/O가 존재한다: \
   스레드는 블로킹 작업(I/O, DB 등)이 발생하면 비활성 상태로 대기하며 자원을 차지한 채 반환하지 않는다.


### [해결 방법]
> 가상 스레드(Virtual Thread) 는 경량화된 사용자 수준의 스레드로, 플랫폼 쓰레드 위에서 JVM이 직접 스케줄링하는 방식이다.

- 기존 플랫폼 쓰레드보다 훨씬 가벼운 많은 가상 스레드 인스턴스를 사용하여 OS 스레드에 매핑합니다.(Java 런타임애서 수행)
- 가상 스레드에서 실행되는 코드가 블로킹 I/O 작업을 호출하면 Java 런타임은 가상 스레드가 재개될 때까지 해당 가상 스레드를 일시 중단한다.  
  일시 중단된 가상 스레드와 연결된 OS 스레드를 다른 가상 스레드와 매핑할 수 있도록 한다.

### [Java 가상 스레드의 장단점]
**장점:**
- **높은 동시성 처리**: 수십만 개의 요청을 하나의 머신에서 효율적으로 처리 가능
- **낮은 메모리 사용량**: 스택 크기가 작고 필요 시 동적으로 조정됨
- **디버깅, 추적 용이**: 스택 트레이스를 그대로 유지하므로, 비동기 콜백 기반보다 디버깅이 쉬움

**단점:**
- **낮은 메모리 사용량**:   
  수십만~수백만의 가상 스레드가 생성될 수 있다면, 얕은 호출 스택을 유지하도록 하는게 필요하다. (공식문서 기준 : HTTP 클라이언트 호출 하나 또는 JDBC 쿼리 하나 정도)
- **CPU-bound 작업에는 적합하지 않다.** 
- **overwhelming** 발생 가능 :   
  Java Application에서 매우 높은 처리량으로 요청을 처리하면 그 뒤에 동작하는 인프라의 처리량이 따라오지 못할 수 있다. (DB connection pool timeout)  
- **Pinned Virtual Threads**:   
  synchronized, native메서드, FFM(Foreign Function and Memory) 을 사용하게 되면 가상 스레드의 장점인 I/O 블로킹 시 비동기적 동작을 수행하지 않는다.


### [Java Virtual Thread 정리]
java 의 OS스레드를 wrapping해서 사용하는 기존 스레드 인스턴스는 동시성의 제약이 있다.\
이를 해소하기 위한 방안으로 가상 스레드를 사용한다.

하지만 불안정 요소와 고려해야 하는 요소가 많이 있기 때문에 도입에 앞서 다방면에서 고려해 보아야 한다. 
> 처리량이 높은 동시 애플리케이션, 특히 대기 시간이 긴 다수의 동시 작업으로 구성된 애플리케이션에서 사용


---

## 결론

가상 메모리와 페이징은 단지 운영체제의 메모리 관리 기술이 아니라, **제한된 자원을 논리적으로 확장하여 사용자에게 더 큰 유연성과 효율을 제공하는 시스템 설계 패턴**이다. 이러한 추상화와 단위 분할의 개념은 다양한 컴퓨팅 영역에서 반복적으로 등장하며, 시스템 이해와 설계의 핵심 원리로 자리잡고 있다.

## 참고
[Virtual Thread 공식문서](https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html) \
[유튜브 kakao tech](https://www.youtube.com/watch?v=vQP6Rs-ywlQ)