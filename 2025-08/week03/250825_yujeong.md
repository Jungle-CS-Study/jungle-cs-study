# 도커, 쿠버네티스 책을 통해 얻어 갈 수 있는것!

한권으로 배우는 도커, 쿠버네티스 책의 주요 목차는 다음과 같다.

2부 쿠버네티스 
   - 7장 쿠버네티스 개념
   - 8장 쿠버네티스 실습 환경 구축 <- 여기 하고 있는 중~
   - 9장 쿠버네티스 기초(여기에 핵심적인 내용이 많은 것 같다)
   - 10장 쿠버네티스를 활용한 웹 서비스 배포
   - 11장 깃허브 액션과 ArgoCD를 활용한 CI/CD 
   - 12장 쿠버네티스 모니터링(프로메테우스, 그라파나 출동)

앞선 6장까지는 도커, 컨테이너에 관한 개념 및 실습 내용이며, 이건 내가 따로 했던 것들이라 바로 쿠버네티스로 넘어갔다!

그리고 7장부터 11장까지는 앞으로 내가 회사에서 해야 할 것들이며, 12장은 현재 구축해서 사용중이지만 사용이 미숙하기도 하고, 쿠버네티스 모니터링은 어떻게 하는지, 또 어떤 메트릭을 보아야 하는지도 모르기 때문에 나에게 도움이 많이 될 것 같다.

# 7장 쿠버네티스 개념

현재는 실습 환경 구축 중이기도 하고, 아직 개념이 미숙한 부분이 많아 개념 공부를 먼저 하려 한다.

### 7.1.1 쿠버네티스란?

쿠버네티스는 컨테이너화된 어플리케이션의 자동 배포, 확장 및 관리를 해주는 오픈소스 플랫폼이다.

### 7.1.2 쿠버네티스의 역할

쿠버네티스는 수 많은 컨테이너를 관리하는 시스템이다.특히 서버를 다수 운영한다면 서로 다른 서버에서 작동하는 수많은 컨테이너를 한꺼번에 관리하는 것은 매우 어려운 일이다.

쿠버네티스를 사용하면 여러 개의 컨테이너를 쉽게 생성하고 관리할 수 있다.

### 7.2.1 쿠버네티스 클러스터

쿠버네티스는 다수의 노드로 구성되는 경우가 많다. 크게 마스터 노드와 워커 노드로 구분되며, 개발자는 주로 마스터 노드와 통신하며, 사용자는 인터넷을 통해 워커 노드와 통신하는 경우가 많다.

책에 그려진 그림을 맘대로 가져오면 안될것같아 말로 표현해보면, 개발자는 마스터 노드에 API 요청을 한다고 적혀있다. 그럼 마스터 노드를 백엔드 서버처럼 쓰는 것일까?

만능 AI 멘토님께 여쭤보았다.

### 마스터 노드의 역할

- 컨트롤 플레인이라고도 부른다
- 주요 구성 요소
    - API Server : 개발자나 kubectl, CI/CD 파이프라인 등 외부에서 오는 모든 요청을 받는 창구(REST API 엔드포인트)
    - Scheduler : 새로운 파드를 어느 워커 노드에 배치할 지 결정
    - Controller Manager : 파드/서비스/ReplicaSet 등이 원래 선언된 상태대로 유지되도록 관리
    - etcd : 클러스터의 상태를 저장하는 Key-value DB

즉, 쿠버네티스 클러스터의 관리자이자 지휘자 같은 존재이다. 실제 애플리케이션(백엔드 서버, 프론트엔드, DB 등)은 워커 노드에서 컨테이너로 실행되고, 사용자는 그쪽과 인터넷을 통해 통신한다.

### 워커 노드의 역할

- 실제로 컨테이너(Pod)가 실행되는 곳
- 주요 구성 요소:
    - kubelet : 마스터와 통신하면서 "이 파드를 실행해라" 같은 명령 수행
    - kube-proxy : 서비스와 네트워크 라우팅 담당
    - Container Runtime : 컨테이너 실행

### 7.2.2 컨트롤 플레인

쿠버네티스 마스터 노드는 컨트롤 플레인을 다루는데, 컨트롤 플레인이란 쿠버네티스 클러스터 전반의 작업을 관리하는 역할을 한다.

위의 GPT 대답에서 나온 생소한 용어들과 함께 컨트롤 플레인을 구성하는 요소에 대해 알아보자

### API 서버(kube-apiserver)

쿠버네티스의 작업은 kubectl 명령어를 통해 마스터 노드의 kube-apiserver에게 API 요청을 보냄으로써 이루어진다. API 서버는 쿠버네티스 컨트롤 플레인에서의 프론트엔드 역할을 한다.

- 모든 컴포넌트들이 오직 kube-apiserver를 통해서만 통신한다.

1. REST API 제공

- kubectl get pods, kubectl apply -f deployment.yaml 같은 명령어는 결국 HTTP(S) 요청이며, API Server가 받게 된다.
- API 요청은 JSON 또는 YAML 형식으로 전달되며, API 서버는 요청을 파싱하고 적절한 리소스(Pod, Service, Deployment)를 생성/조회/수정/삭제(CRUD)

2. 인증(Authentication) & 인가(Authorization)

- API 서버는 클러스터 보안을 위해 요청자가 누구인지 확인하고, 해당 요청을 할 수 있는 권한이 있는지 확인해야 함

3. Admission Control (승인 단계)
- 인증/인가가 끝난 후, 이 요청이 클러스터 정책에 맞는지 확인. 예를 들면, 특정 네임스페이스에 Pod는 10개 이상 만들 수 없음과 같은 정책
- 이 과정을 통과해야 리소스 생성이 최종적으로 진행됨

4. etcd와의 통신(저장소 역할)

- API 서버는 모든 요청을 etcd라는 Key-value DB에 최종적으로 기록한다.
- etcd는 쿠버네티스의 상태 저장소 

5. 컨트롤러와 통신(Watch 매커니즘)

- API 서버는 단순 데이터만 저장하는게 아니라, 다른 컴포넌트들과 Watch 매커니즘 방식으로 동작한다.
- 예: Deployment 리소스가 생성되면 → Controller Manager가 API Server에서 변경 사항 감지 → ReplicaSet 생성 → Scheduler가 Pod를 노드에 배치 → kubelet이 API Server에서 "내가 실행할 Pod가 있나?" 확인.

즉, 모든 컴포넌트의 이벤트가 API 서버를 중심으로 연결된다.

### etcd

쿠버네티스 클러스터에 존재하는 모든 데이터를 저장하는 key-value 저장소이다.

쿠버네티스가 관리하는 상태는 단순한 데이터 구조이다. 이 데이터들은 모두 key로 식별 가능한 값들이다.

```
/api/v1/namespaces/default/pods/nginx-12345
→ { "status": "Running", "nodeName": "worker1", ... }
```

따라서 DB 스키마나 관계형 JOIN 같은게 필요없고, 빠른 읽기/쓰기 + 일관성이 중요하기에 key-value DB가 최적이다.

또한, etcd는 디스크 기반 저장소이다. 기본적으로 Write-Ahead Log(트랜잭션 로그)와 스냅샷 파일(일정 시점의 전체 상태를 찍은 파일)을 디스크에 저장하며, 읽기/쓰기 캐시는 메모리를 활용해 속도를 보장하기도 한다.

여러 노드에 동일하게 저장되며, 마스터 노드 여러개가 있어도 항상 같은 클러스터 상태를 유지한다.

### 스케줄러

쿠버네티스에서는 이후 배울 Pod라는 오브젝트를 통해 애플리케이션을 실행한다. 파드는 쿠버네티스 클러스터를 구성하는 노드 중 하나에 실행되며, 이때 새롭게 생성되는 파드를 어느 노드에 실행시킬지 정하는 역할을 kube-scheduler가 수행한다.

### 컨트롤러 매니저

컨트롤러 매니저는 쿠버네티스 리소스를 관리하고 제어하는 역할을 한다. 컨트롤러는 마스터 노드에서 실행되며, 클러스터 상태를 모니터링한다. 컨트롤러에는 디플로이먼트, 컨트롤러, 서비스 컨트롤러, 레플리카셋 컨트롤러 등의 여러 종류가 있으며, 각 컨트롤러는 특정 리소스 타입을 관리한다.