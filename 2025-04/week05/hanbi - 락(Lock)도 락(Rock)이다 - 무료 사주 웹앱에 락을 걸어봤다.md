블로그로 보시면 더욱 읽기 편합니다. 👉[바로가기](https://coder-narak.tistory.com/53)  
발표용 슬라이드도 준비되어 있습니다. 👉[바로가기](https://www.figma.com/deck/2OLxUbh7Q9Znn7kAu5hwA0/CS-%EC%8A%A4%ED%84%B0%EB%94%94---Lock?node-id=0-1&t=4a0v7as14u8vglaa-1)

# 락(Lock)도 락(Rock)이다: 무료 사주 웹앱에 락을 걸어봤다

> 이 글은 컴퓨터 과학(CS)을 공부하면서 생긴 질문을 정리하고, 스스로 답을 찾아가는 과정을 담았습니다. 읽기 쉽게 풀어 썼으니, 비전공자나 개발자가 아니어도 편하게 읽어주시면 좋겠습니다. 락(lock)은 하나의 자원에 여러 요청이 몰릴 때, 충돌을 방지하고 흐름을 제어하기 위해 사용하는 구조입니다. 이번 글에서는 이 개념을 실제 서비스에 어떻게 적용했는지, 직접 부딪히며 배운 시행착오를 통해 풀어보려 합니다.

처음에는 그냥 재미로 만들었다. 무료 사주 웹앱 하나쯤이야. 버튼 누르면 GPT가 사주를 분석해주는 아주 단순한 구조. 그런데 그 단순함이 예상치 못한 문제를 불러왔다. 버튼을 한 번만 누르지 않을 가능성. 두 번 누르면? API는 두 번 호출되고, 비용도 두 번 나간다. 결과는 꼬이고, UX는 나빠진다. 내가 만든 건 서비스가 아니라, 중복 호출 트랩이었다.  
  
이 글은 그 문제를 어떻게 풀었는지, 그리고 그 과정에서 **락(lock)**이라는 개념을 기술과 실전 사이에서 어떻게 이해하게 되었는지 정리한 기록이다. CS 교과서에서 락을 처음 배울 때의 의문, 실제 서비스에 적용하면서 느낀 고민, 그리고 그걸 통해 배운 현실적인 판단 기준까지 담았다.

---

## **1\. 버튼을 눌렀을 뿐인데, GPT가 두 번 돌아갔다**

GPT 철학관이라는 이름의 작은 실험을 시작했다. 사주 정보를 입력하면 ChatGPT가 분석 결과를 텍스트로 내려주는 웹앱이었다. 처음엔 가볍게 테스트하고 말 생각이었다. 그런데 너무 가볍게 눌렀다. 버튼을 연달아 두 번 누르면 어떤 일이 생길까?

-   서버는 같은 요청을 **두 번 받는다**
-   GPT는 두 번 호출된다 → **비용도 두 배**
-   응답은 순서가 꼬일 수 있다 → **UX 오류**
-   첫 응답은 버려지고, 마지막 응답만 표시된다
-   그런데 **두 번 모두 과금된다**

요컨대, **아직 누구한테 보여주지도 않았는데, 나 혼자 쓰다가 돈이 새고 있었던 셈이다.**

> **💡 Beginner’s Note:** 같은 요청이 두 번 날아가면, 비용이 두 배로 들고 결과도 꼬일 수 있다. 이런 문제를 막기 위해 중복 요청을 제한하는 장치가 필요하다. 이를 위해 사용하는 개념이 락(lock)이며, 이는 자원에 대한 접근을 제어해 정합성과 안정성을 지킨다.

> **🧠 CS 관점 정리:** 이 상황은 ‘중복 호출에 따른 리소스 낭비와 비정상 상태’로, 동시성 제어가 필요한 전형적인 케이스다. 락은 이런 경우에 자원의 선점과 보호를 위해 사용된다.

---

## **2\. 프론트엔드에서 먼저 ‘막아봤다’**

개발자로서 처음 할 수 있는 대응은 ‘프론트엔드 락’이었다. 즉, **UI 레벨에서 중복 클릭을 막는 것**이다.

```
if (submitted) return;
```

버튼을 클릭하면 submitted 상태를 true로 바꾸고, 이후 클릭은 무시한다. 로딩 메시지를 함께 보여주면 사용자는 기다리는 상태를 인식할 수 있다. 대부분의 빠른 클릭은 이 정도로 충분히 막을 수 있다.

**하지만 한계는 명확했다.**

-   사용자가 새 탭을 열면? 다시 요청 가능
-   누군가 브라우저에서 API를 직접 호출하면? 무방비
-   실제로 API는 서버 기준으로 **새로운 요청**을 받고 있었다

프론트엔드는 어디까지나 **브라우저 수준의 UX 제어**일 뿐이다. 진짜 자원을 보호하려면, **서버에서** 락을 걸어야 했다.

> **💡 Beginner’s Note:** 버튼을 너무 빨리 누르면 서버가 준비되기 전에 다시 호출될 수 있다. 이걸 막으려면 클릭 후 상태를 바꿔주면 된다. 아주 기본적인 UX 제어 방법이다.

> **🧠 CS 관점 정리:** 이 방식은 클라이언트 레벨의 상태 제어이며, 실제 자원 보호는 불가능하다. 락으로 분류되진 않으며, UI 차원의 방어 로직으로 분류된다.

---

## **3\. 백엔드에서 Redis로 ‘진짜 락’을 걸다**

락이라고 하면 복잡한 OS 개념을 떠올릴 수 있지만, 내가 필요했던 건 단순했다.

> **“같은 사용자가 10초 안에 또 요청하면 막자.”**

Redis는 이 목적에 아주 잘 맞는 도구였다.

-   빠르다: 메모리 기반이라 거의 실시간
-   TTL(Time To Live): 잠금 유지 시간을 지정할 수 있음
-   키-값 구조: 사용자 단위로 제어 가능

### **3-1. 사용자 구분 기준은 ‘IP’**

로그인 기능이 없는 무료 서비스였기 때문에, 사용자 ID는 없었다. 그래서 **IP 주소**를 기준으로 락 키를 구성했다.

```
const ip = req.headers['x-forwarded-for']?.split(',')[0] || req.socket.remoteAddress || 'unknown';
const lockKey = `lock:gpt:${ip}`;
```

물론 IP만으로 사용자를 완벽히 식별하긴 어렵지만, 테스트용 서비스에서는 충분한 기준이었다.

### **3-2. 락이 걸리는 과정**

#### **1) 락이 있는지 먼저 확인**

```
const isLocked = await redis.get(lockKey);
if (isLocked) {
  return res.status(429).json({ error: '이미 분석 중입니다.' });
}
```

Redis에서 해당 키가 존재하면, 이미 요청 중이라는 의미다. 즉시 요청을 거절하고, 프론트에는 안내 메시지를 띄운다.

> “너무 빠르게 요청했어요. 잠시 후 다시 시도해 주세요.”

#### **2) 락을 건다**

```
await redis.set(lockKey, '1', 'EX', 10);
```

-   '1': 값은 중요하지 않다. 존재 여부만 확인함
-   'EX', 10: 10초간 유지되며, 그 이후 자동으로 해제됨

이제 같은 IP에서 10초 안에 다시 요청하면 거절된다.

#### **3) 응답이 끝나면 락을 해제한다**

```
finally {
  await redis.del(lockKey);
}
```

TTL이 있어도 명시적으로 삭제하는 게 안정적이다. 혹시라도 에러가 발생해도 락이 유지되는 것을 방지할 수 있다.

### **3-3. 락이 정말 걸렸는지 확인하고 싶다면?**

락을 걸었으면, 진짜 작동하는지도 확인하고 싶어진다. 아래는 Redis에서 락 상태를 확인하거나 직접 해제할 수 있는 명령어다.

```
# 현재 락 상태 확인
GET lock:gpt:<ip>

# TTL(락 남은 시간) 확인
TTL lock:gpt:<ip>

# 강제로 락 해제
DEL lock:gpt:<ip>
```

개발 단계에서는 자주 쓰게 되지만, 실서비스에서는 사용자나 클라이언트에서 직접 건드릴 수 없어야 한다. 이건 운영자의 백스테이지 도구라고 생각하면 좋다. 그리고 테스트할 땐 콘솔 로그를 켜두면 이런 메시지를 확인할 수 있다:

```
🛑 락 걸려 있음, 요청 거절됨: lock:gpt:127.0.0.1
```

확실히 거절됐고, 프론트에서도 “너무 빠르게 요청했어요” 같은 안내 메시지가 떴다면, 락은 제대로 걸린 거다.

> **💡 Beginner’s Note:** 서버에서도 요청을 제한해야 진짜 자원을 보호할 수 있다. Redis를 이용하면, ‘지금은 처리 중이니 잠시만요’ 같은 구조를 만들 수 있다.

> **🧠 CS 관점 정리:** Redis를 활용한 TTL 기반 제어는 Soft Lock에 해당한다. 분산 환경에서의 락 구현 방식 중 하나이며, 해제 타이밍이 명확하지 않다는 점에서 전통적인 Mutex와는 구분된다.

---

## **4\.** **사용 횟수까지 제한해보자**

프론트엔드 락으로 버튼 연타를 막고, 백엔드 락으로 동시에 들어오는 요청을 제어했지만, 문제는 남았다. **무한 요청**이다. 버튼을 천천히 여러 번 눌러도, 하루에 열 번, 스무 번 눌러도 문제 없이 GPT 호출이 가능하다. 서비스는 무료고, 나는 매번 GPT API 비용을 내야 한다. 한마디로, 끝이 없다. 그래서 세 번째 수단을 꺼냈다. **사용 횟수 제한**이다.

-   하루 3번까지만 요청 가능
-   Redis에 IP 기준으로 카운트를 저장
-   첫 호출 시 24시간 TTL 설정

```
const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
const key = `limit:${ip}:${today}`;
const count = await redis.incr(key);

if (count === 1) {
  await redis.expire(key, 60 * 60 * 24); // 하루 유효
}

if (count > 3) {
  return res.status(429).json({ message: '❗ 하루 3회까지만 이용할 수 있어요. 내일 다시 시도해주세요.' });
}
```

> **💡 Beginner’s Note:** 한두 번은 막아도, 계속 누르면 결국 비용이 쌓인다. 그래서 하루 사용 횟수를 정해두는 것도 중요하다. IP별로 횟수를 세고 제한하는 방법이 그 해법이다.

> **🧠 CS 관점 정리:** 이 방식은 락이 아닌 Rate Limiting 전략이다. 자원 보호보다는 사용량 제어에 초점이 맞춰져 있으며, API 게이트웨이에서도 널리 사용된다.

---

## **5\. 이게 진짜 락이었을까?**

돌이켜보면 나는 세 가지 방법을 사용했다.

1.  **프론트엔드 락** – UI에서 빠른 클릭을 막기
2.  **백엔드 락** – Redis로 일정 시간 동안 요청 차단
3.  **사용 횟수 제한** – 하루 3번이라는 사용량 캡 설정

처음엔 세 개 다 ‘락’이라고 부르면 되지 않을까 싶었다. 어차피 요청을 “잠깐 멈추는” 구조니까. 하지만 CS(컴퓨터 과학)에서 말하는 **락(Lock)**은 조금 더 까다롭고 정교하다. 

> **💡 Beginner’s Note:** 세 가지 방식 모두 ‘요청을 잠깐 멈춘다’는 점에서는 비슷하지만, 기술적으로는 다른 개념이다. 이름이 같다고 다 같은 락은 아니다.

> **🧠 CS 관점 정리:** CS에서 락은 정합성 보장을 위한 제어 장치이며, 락의 성격은 그 사용 방식과 해제 조건, 대상 자원에 따라 구분된다.

---

## **6\.** **CS에서 말하는 락은 이런 것**

락은 여러 프로세스(또는 스레드)가 하나의 데이터나 자원에 동시에 접근하려고 할 때, 데이터 정합성을 지키기 위해 등장한 개념이다.  
  
예를 들어, A와 B가 동시에 같은 계좌 정보를 수정하려고 하면 어떤 문제가 생길까? 한쪽의 변경이 덮어쓰기되거나, 중간 상태가 저장될 수 있다. 이런 문제를 막기 위해 CS에서는 다양한 락 전략이 사용된다.

-   **Mutex (Mutual Exclusion):** 한 번에 하나만 접근 허용
-   **Semaphore:** 자원 수에 따라 여러 접근 허용
-   **Read/Write Lock:** 읽기는 여러 개, 쓰기는 하나만 허용
-   **Spinlock / Distributed Lock:** 병렬 시스템과 분산 시스템에서 더 복잡하게 확장

그리고 무엇보다 중요한 건, **누가 먼저 자원을 사용하고, 언제 어떻게 해제하는지**를 정확하게 다룬다는 점이다.

> **💡 Beginner’s Note:** 락은 단순히 막는 게 아니라, 여러 사용자가 동시에 자원에 접근하지 못하게 하는 규칙이다. 서로 엉키지 않도록 교통정리를 해주는 셈이다.

> **🧠 CS 관점 정리:** 락(lock)은 Concurrency Control의 대표 전략이다. 자원에 대한 Mutual Exclusion을 보장해 Race Condition을 방지한다.

---

## **7\.** **내가 한 것들은 락이 아니었나?**

이제 정리해보자. 내가 시도한 세 가지는 CS 기준에서 보면 아래와 같이 분류된다.

| **내가 한 것**    | **CS에서 본다면…** |
| --- | --- |
| 프론트엔드 상태값 제어 | ❌ 락 아님. UX 수준의 클릭 제한 |
| Redis로 TTL 락 걸기 | 🔸 기술적으로는 Soft Lock. 락과 유사 동작 |
| 하루 3회 요청 제한 | ❌ 락 아님. Rate Limiting 기법 |

-   **프론트엔드 락**은 말 그대로 “클릭 방지용 if문”이다. 브라우저 안에서만 동작하고, 자원을 보호하지 않는다.
-   **Redis 락**은 분명 일정 시간 동안 중복 요청을 막았다. 하지만 락 해제 시점을 사용자 요청 흐름이 아닌 TTL로 다루기 때문에, 전통적인 락이라고 보긴 어렵다. 다만 “선점 제어”라는 측면에선 유사하다.
-   **사용 횟수 제한**은 락과는 아예 결이 다르다. 이건 **Rate Limiting**이라는 별개의 전략이다. API 게이트웨이, 서버 보안 등에서도 자주 쓰이는 방식이다.

요약하면, **CS에서 말하는 락과는 다르지만, 서비스 보호라는 목적에서는 닮아 있었다.** 엄밀히 락은 아니지만, 내가 필요로 했던 기능을 하는 데엔 충분했다.

> **💡 Beginner’s Note:** 내가 구현한 방식도 요청을 막긴 했지만, 기술적으로는 전통적인 락이 아니다. 그래도 ‘락처럼 동작’했기에 실무에서는 충분히 쓸모 있었다.

> **🧠 CS 관점 정리:** TTL 기반 제한은 Optimistic Lock이나 Soft Lock으로 볼 수 있으며, 상태값 제어나 Rate Limit은 락으로 분류되지 않는다.

---

## **8\. 그런데 왜 이게 중요한가?**

**락이라는 단어를 아는 것**과 **락을 언제, 왜 써야 하는지 아는 것**은 다르다. 나는 락이라는 개념을 배웠다. 하지만 실제로 그걸 써야 했을 땐, 책에 나온 정답보다 **내 서비스의 현실과 내가 감당할 수 있는 구조**가 먼저 떠올랐다.

-   CS에서 보호하는 것은 메모리 정합성이지만, 나는 GPT 호출 비용을 보호하고 싶었다.
-   CS에서 방지하는 것은 스레드 충돌이지만, 나는 사용자 요청의 중복을 막고 싶었다.
-   CS에서 따지는 건 데이터 정합성이지만, 나는 운영 안정성과 UX 흐름을 우선시했다.

그 결과, CS 정의에 딱 들어맞진 않지만, **서비스를 지키기 위한 현실적인 제어 장치**를 만들었다. 그리고 그걸 **락처럼 쓸 수 있었다**는 사실이 중요했다.

> **💡 Beginner’s Note:** 락이란 단어를 아는 것보다, 언제 락이 필요한지를 아는 게 더 중요하다. 내 서비스 상황에 맞는 제어 방법을 선택하는 게 핵심이다.

> **🧠 CS 관점 정리:** 이론적 정의보다 중요한 것은 실행 맥락에서의 적절한 설계 판단이다. 동시성 문제를 예방하는 실질적 사고가 DevOps에 더 필요하다.

---

## **9\. 마무리: 락도, 락이다**

락은 단순한 이론이 아니다. 중요한 건, 내가 감당할 수 있는 구조 안에서 어떻게 적용하느냐다. 이번에 구현한 방식은 전통적인 락은 아니었지만, 서비스 운영에는 충분히 유효했다. 무엇보다, 이게 락인지 아닌지를 스스로 판단할 수 있을 만큼 고민했다는 것, 그게 가장 큰 수확이었다. 내 서비스에도, 내 공부에도, 충분히 쓸모 있었다. **락도, 락이다.** **🤘**

```
이 실험에서 배운 것
- 프론트엔드 상태 제어는 UX 차원의 대응이다.
- Redis TTL 락은 완전한 락은 아니지만, 실무에서 유용하다.
- 사용 횟수 제한은 Rate Limiting이며 락과 목적이 다르다.
- 기술 개념을 서비스 환경에 맞게 해석하고 적용할 수 있어야 한다.
```

> **💡 Beginner’s Note:** 락은 거창한 개념이 아니다. 현실적인 상황에서 내 서비스에 꼭 맞는 방식으로 써먹을 수 있는 도구였다. 그래서 충분히 쓸모 있었다.

> **🧠 CS 관점 정리:** 실제 시스템에서는 완전한 락보다 현실적인 우회 전략이 더 중요할 수 있다. 목적은 개념의 충족이 아닌 서비스의 안정성 확보다.
