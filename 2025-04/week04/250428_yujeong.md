# 시스템 콜

## kill() 과 bind()
kill() : 프로세스에 "시그널"을 보내서 프로세스에 어떤 행동을 하도록 요청하는 것   
→ *"시그널" 은 어떤 형태로 프로세스에 보내지며, 어떤 과정을 거쳐 프로세스에 전해질까?*


### 주제 선정 배경

### 문제 상황!
dash 앱을 4월 21일에 배포 후, 다음 날 출근했을 때, 리눅스 터미널 세션이 닫힘(정확히 닫힌건지, dash 앱이 비정상적으로 터지면서 linux 세션까지 멈춰버린건지 가물가물함..). 

그러면서 dash 앱도 같이 배포가 종료되어, 윈도우에서 하던 것처럼 똑같이 gunicorn app:server --bind ~로 배포를 했지만 *Address already in use* 에러가 발생함. 

찾아보니 이전에 띄웠던 앱의 프로세스가 아직 살아있거나, 좀비처럼 포트를 점유하는 상황.
→*어떤 과정으로 좀비 상태가 된 걸까?*

### Address already in use (Bind Failed) 에러란?

서버 역할을 하는 프로그램(nginx, tomcat, java(spring), python(django), nodejs 등)이 리눅스 서버 내에서 특정 IP 주소와 Port 번호를 사용하려고 할 때, bind 시스템 콜을 사용하게 됨.

그런데 이미 다른 프로세스가 해당 Port 번호를 이미 사용하고 있을 때, 포트 충돌로 인한 Bind Failed 에러가 발생할 수 있음.

[참고 링크] https://reallinux.co.kr/blog/199

### 해결 과정

먼저, 점유 중인 PID를 확인했음

*PID : Process ID, 운영체제에서 프로세스를 식별하기 위해 사용하는 고유한 번호.*   

```
sudo netstat -tnlp | grep 9000
```

그 결과 
```
tcp    0    0    0.0.0.0:9000    0.0.0.0:*    LISTEN    29346/python3
```

이렇게 떴고, 여기서 **29346**이 포트를 점유한 PID였음.

*--workers 4 이렇게 멀티 프로세스를 사용한 경우, 총 다섯개의 프로세스 목록이 뜸. 거기서 가장 위의 프로세스가 마스터 프로세스로, 마스터를 kill 하면 한꺼번에 종료 됨*

검색 결과 많은 블로그에서 이 문제 해결 방식으로 kill -9을 통해 종료시켰지만, https://reallinux.co.kr/blog/199  이 블로그에서는 그런 방식의 문제점을 지적하고 있었음

kill 9 으로 강제종료를 시키게 되면, **시스템 자원해지를 정상적으로 하지 못하고 종료가 될 수 있고, 이는 다른 부작용 발생 여지가 있다는게 문제점이었음.**

9번은 강제 종료, 15번은 일반적인 종료의 시그널임.

그래서 
```
sudo kill -15 29346 
```
이런식으로 종료해야 한다는게 글쓴이의 의견이었음.

### kill 시스템 콜

참고 링크 https://www.joinc.co.kr/w/man/2/kill

kill() 시스템 콜은 특정 프로세스나 프로세스 그룹에 시그널을 보내기 위해서 사용한다.

```
#include <sys/types.h>

#include <signal.h>

int kill(pid_t pid, int sig);
```


kill -15 종료 로직

1. 열려 있던 파일 닫기

2. 데이터베이스 연결 끊기

3. 메모리 해제

4. 임시 파일 정리

5. 로그 남기기 등

정상적인 종료과정은 위와 같고, 자원 해제가 제대로 일어남.

하지만 kill -9의 경우, **커널이 프로세스를 즉시 종료**시키는데, 자원 해제 할 기회를 아예 갖지 못함. 
→ *커널이 프로세스를 **즉시** 종료시킨다는 것의 의미?*

메모리, 파일, 네트워크 소켓 등이 닫히지 않을 수 있음. 그 결과, 소켓이 열려있는 상태로 남아 포트를 점유하고, 임시 파일이 디스크에 그대로 남는 등의 문제가 생김

그럼에도 불구하고 kill -9 을 권유하는 글이 많은 이유는, -15로 종료시킴에도 프로세스가 무한 루프, 데드락, 응답 없음 등으로 종료되지 않는 경우가 있기 때문.​ 

### kill -9 실행 과정
kill -9 시그널이 프로세스에 전달되면, 프로세스에서는 어떤 일이 일어나는지 궁금했다.
어떤 과정을 거쳐서 프로세스를 죽일까?

1. 먼저, kill -9는 SIGKILL 이라는 시그널을 보냄. 

이때, 프로세스는 시그널을 **받을 수는 있지만, 처리할 수는 없다**
→ 받을 수는 있지만 처리할 수는 없다는게 무슨 말일까까

커널이 시그널을 전달하면, 프로세스가 어떤 정리(cleanup) 작업도 하지 못하고 즉시 제거된다.

운영체제가 프로세스 테이블에서 강제로 퇴장 시키는 것과 같다.

```
#include <sys/types.h>

#include <signal.h>

int kill(pid_t pid, int sig);
```

* pid가 양수라면 sig 시그널을 pid로 보낸다.
* pid가 0이면 현재 프로세스가 속한 프로세스 그룹의 모든 프로세스에게 sig 시그널을 보낸다.
* pid 가 -1이면, 1번 프로세스를 제외한 모든 프로세스에서 sig 시그널을 보낸다.
* pid 가 -1보다 작으면, -pid 프로세스가 포함된 모든 그룹의 프로세스에게 sig 시그널을 보낸다.
* sig가 0이면 어떤 시그널도 보내지 않지만, 에러 검사는 할 수 있다. 