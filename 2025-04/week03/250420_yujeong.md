# Dash 앱 성능 병목 분석 및 리팩토링 아키텍처 제안

## 1. 서론
- **실무 상황 소개**: Windows 서버 + Dash + Waitress 환경 (내가 작성한 코드는 아님)
  - CPU: 4코어, 메모리: 8GB
- **발생한 문제**: `waitress.queue: Task queue depth is 1` 로그 발생 및 요청이 들어오자마자 CPU 사용률이 100%에 도달함
  - GPT의 조언에 따라 스레드 수를 늘려 일시적으로 해결했지만, 근본적인 원인과 스레드의 관계를 이해하기 어려웠음
- **자료 작성 목적**: 해당 문제를 OS 및 언어/프레임워크 관점에서 분석하고, 개선 방향을 탐색
- **실제 대응**: 각 서비스마다 스레드를 임시로 16개까지 배정함
  - 하지만 일반적으로 CPU 바운드 작업의 경우, 적정 스레드 수는 'CPU 코어 수 + 1'이 가장 효율적이라고 알려져 있음
  - 스레드가 너무 많으면 Context Switching 오버헤드 발생으로 오히려 성능이 저하될 수 있음
  - 현재 서버는 4코어이므로, 서비스당 5개 정도의 스레드가 적정하다고 판단됨
  - 그러나 Python의 GIL과 waitress의 구조적 특성으로 인해 멀티스레딩/멀티프로세싱 모두 실질적으로 병렬 처리가 어려움
  - 모든 상황에서 멀티스레딩이 싱글스레드보다 좋은 것도 아니며, 구조적인 개선이 필요하다고 느꼈음

현재는 리눅스 서버를 기반으로 구조 개선 중

## 2. 문제 현상과 원인 분석

### 2.1 Dash + Waitress 구조 이해
- 단일 프로세스 / 멀티스레드 구조
- WSGI 기반 처리 방식
  - WSGI: Python 웹 애플리케이션과 웹 서버 간의 표준 인터페이스
- **GIL (Global Interpreter Lock)**
  - CPython 인터프리터의 메모리 안정성을 위해 도입된 전역 락
  - 동시에 하나의 스레드만 Python 바이트코드를 실행할 수 있음
  - I/O-bound 작업에는 큰 문제가 없지만, CPU-bound 작업에서는 병목 발생
- Dash 앱은 Pandas, Numpy 기반의 무거운 계산이 많아 대부분 CPU-bound 작업
- **GIL vs 동기화 기법**
  - GIL은 인터프리터 내부 구조의 제한이며 개발자가 제어할 수 없음
  - 동기화 기법(뮤텍스, 세마포어 등)은 개발자가 특정 자원의 동시 접근을 제어하기 위해 사용
- **싱글 스레드 vs 멀티 스레드**
  - 싱글 스레드는 구조가 단순해 개발과 자원 관리가 쉬움
  - 멀티 스레드는 성능 향상을 기대할 수 있지만, 동기화, 데드락, 메모리 누수 등 관리가 복잡함
  - CPU 바운드 작업이라고 해서 무조건 멀티스레드가 정답은 아님. 병렬화로 인한 성능 향상이 코드 복잡도를 상회할 때에만 적절

### 2.2 queue depth 현상의 본질
- `waitress.queue: Task queue depth is 1` 로그가 발생하는 조건:
  - Dash의 콜백 함수가 HTTP 요청을 통해 실행되려 할 때, 모든 스레드가 바쁘면 요청이 대기 큐에 쌓이게 됨
- **HTTP 요청 ≠ 단순 접속**: 사용자가 접속만 한 상태가 아니라, 그래프 업데이트 등 명확한 요청이 발생했을 때
- **GIL 점유로 인한 순차 처리**:
  ```
  시간 t0: 사용자 A 요청 → 스레드 1 실행 (GIL 획득)
  시간 t1: 사용자 B 요청 → 스레드 2 대기 (GIL 없음)
  시간 t2: 사용자 C 요청 → 스레드 3 대기
  시간 t3: 사용자 A 응답 완료 → GIL 반납 → B 실행 시작
  ```
- **스레드 수 증가로도 해결되지 않는 이유**:
  - Waitress는 멀티스레드를 지원하지만, Python의 GIL이 병목을 발생시킴
  - 실제 CPU-bound 작업 시에는 하나의 스레드만 실행되고, 나머지는 대기
  - 오히려 많은 스레드는 Context Switching 오버헤드만 증가시킬 수 있음

## 3. 운영체제 관점에서 본 구조적 한계
- 인터프리터 언어(Python)는 JIT 컴파일이 없고, GIL로 인해 병렬 처리에 약함
- 멀티코어 시스템의 자원을 제대로 활용하지 못함
- 반면, Java는 운영체제의 커널 스레드를 직접 활용할 수 있고, 멀티코어를 효율적으로 사용할 수 있음
- Java의 스레드풀, 비동기 처리, JIT 컴파일 기능 등을 통해 CPU 바운드 작업에 강한 구조를 가짐

## 4. 대안 아키텍처 설계

### 4.1 제안 구조 개요
React + Java(Spring) + Python(연산 전용) + Redis + MySQL

### 4.2 역할 분리
| 구성 요소 | 역할 |
|-----------|------|
| React | UI 렌더링, 그래프 표시 |
| Spring | REST API 처리, Redis 캐시 처리 |
| Python | 계산 전용 서버 (pandas, numpy 활용) |
| Redis | 연산 결과 캐시 저장 (TTL 설정) |
| MySQL | 영속적 데이터 저장소 |

### 4.3 동작 흐름
1. 사용자 버튼 클릭 → React → Spring API 요청
2. Spring: Redis에 캐시된 결과 있는지 확인
3. 없을 경우, Python 연산 서버에 요청 전송
4. Python 연산 완료 → Redis에 결과 저장
5. Spring → React로 응답 → 사용자 화면 출력

## 5. 언어 비교: Python vs Java

| 항목 | Python | Java |
|------|--------|------|
| GIL 존재 | ✅ 있음 | ❌ 없음 |
| CPU 병렬 처리 | ❌ 제한적 (multiprocessing 필요) | ✅ 멀티스레드 지원, 효율적 병렬 처리 |
| I/O 효율 | 보통 | 매우 우수 (NIO, 비동기 처리) |
| 계산 최적화 | pandas, numpy 활용 | 기본 언어만으로는 약함 (고성능 연산은 외부 라이브러리 필요) |
| API 서버 성능 | 느림 (동기 기반, 병목 잦음) | 빠르고 안정적 (비동기, 스레드풀 구조) |
| 프레임워크 | Flask, FastAPI | Spring Boot, Micronaut |
| 확장성 | 제한적 (단일 프로세스 기반) | 수평 확장 용이 (멀티 인스턴스, 로드 밸런싱) |

※ 멀티스레딩이 항상 정답은 아니며, 개발 복잡성과 성능 이득을 비교하여 판단해야 함

## 6. Redis vs MySQL: 캐시와 저장소의 역할 구분

- Redis: 인메모리 기반 초고속 캐시 저장소, TTL 기반 만료 처리
- MySQL: 디스크 기반 관계형 DB로, 영속적 데이터 저장
- 일반적으로 Redis는 실시간 응답을 위한 임시 저장소, MySQL은 신뢰성 있는 영구 저장소로 병행 사용함
- Redis에는 연산 결과, 조회 빈도가 높은 값, 통계 등을 캐싱함 (DB 부하 분산)
- TTL, 캐시 무효화 전략 등은 응답성과 최신성 사이의 균형을 조절하는 데 중요함
